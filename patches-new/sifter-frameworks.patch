diff --git a/core/jni/Android.bp b/core/jni/Android.bp
index 9eb985036088..ffff848da684 100644
--- a/core/jni/Android.bp
+++ b/core/jni/Android.bp
@@ -389,6 +389,7 @@ cc_library_shared_for_libandroid_runtime {
                 "libperfetto_c",
                 "libtracing_perfetto",
                 "libperfetto_framework_jni",
+		"libbpf",
             ],
             export_shared_lib_headers: [
                 // our headers include libnativewindow's public headers
diff --git a/core/jni/com_android_internal_os_Zygote.cpp b/core/jni/com_android_internal_os_Zygote.cpp
index 344cb44c26af..17bb729f6051 100644
--- a/core/jni/com_android_internal_os_Zygote.cpp
+++ b/core/jni/com_android_internal_os_Zygote.cpp
@@ -92,6 +92,105 @@
 extern "C" void android_reset_stack_guards();
 #endif
 
+//sifter
+#include <bpf/bpf.h>
+
+#include <iostream>
+#include <string>
+#include <memory>
+#include <stdexcept>
+#include <vector>
+
+#include <sys/syscall.h>
+#include <linux/seccomp.h>
+#include <cstdarg>
+#include <cstdio>
+
+// Defining a BPF program type for seccomp filters.
+constexpr int BPF_PROG_TYPE_SECCOMP = 32;
+
+
+/**
+ * @brief attaches seccomp filter bpf program.
+ *
+ * @param prog_name The name of the program within the BPF object file to load.
+ * @return true if the program and maps were successfully loaded and pinned, false otherwise.
+ */
+bool attachBpfProgram(const std::string& prog_name) {
+	std::string pin_path_str = "/sys/fs/bpf/prog_" + prog_name;
+	const char* pin_path_prog = pin_path_str.c_str();
+	int prog_fd = bpf_obj_get(pin_path_prog);
+        if (prog_fd < 0) {
+		ALOGE("filterLoader: Failed to get program file descriptor for %s: %s", pin_path_prog, strerror(errno));
+		return false;
+        }
+	
+	ALOGI("filterLoader: Attaching seccomp filter...");
+        
+	if (syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER_EXTENDED, 0, &prog_fd) != 0) {
+		ALOGE("filterLoader: Failed to attach seccomp filter.");
+		return false;
+        }
+
+	ALOGI("filterLoader: Seccomp filter attached successfully!");
+	
+    return true; 
+}
+
+
+int applyFilterForChrome() {
+
+    const std::vector<std::string> prog_names = {
+        "filter_seq",
+        "filter_fstat",
+	"filter_mmap_bifrost",
+	"filter_read",
+	"filter_ioctl_KBASE_IOCTL_CS_QUEUE_REGISTER",
+    	"filter_ioctl_KBASE_IOCTL_KCPU_QUEUE_ENQUEUE",
+    	"filter_ioctl_KBASE_IOCTL_READ_USER_PAGE",
+    	"filter_ioctl_KBASE_IOCTL_CS_QUEUE_TERMINATE",
+    	"filter_ioctl_KBASE_IOCTL_MEM_ALLOC_EX",
+    	"filter_ioctl_KBASE_IOCTL_SET_FLAGS",
+    	"filter_ioctl_KBASE_IOCTL_CONTEXT_PRIORITY_CHECK",
+    	"filter_ioctl_KBASE_IOCTL_CS_TILER_HEAP_INIT",
+    	"filter_ioctl_KBASE_IOCTL_MEM_COMMIT",
+    	"filter_ioctl_KBASE_IOCTL_STICKY_RESOURCE_MAP",
+    	"filter_ioctl_KBASE_IOCTL_CS_EVENT_SIGNAL",
+    	"filter_ioctl_KBASE_IOCTL_CS_TILER_HEAP_TERM",
+    	"filter_ioctl_KBASE_IOCTL_MEM_EXEC_INIT",
+    	"filter_ioctl_KBASE_IOCTL_STICKY_RESOURCE_UNMAP",
+    	"filter_ioctl_KBASE_IOCTL_CS_GET_GLB_IFACE",
+    	"filter_ioctl_KBASE_IOCTL_FENCE_VALIDATE",
+    	"filter_ioctl_KBASE_IOCTL_MEM_FREE",
+    	"filter_ioctl_KBASE_IOCTL_CS_QUEUE_BIND",
+    	"filter_ioctl_KBASE_IOCTL_GET_CONTEXT_ID",
+    	"filter_ioctl_KBASE_IOCTL_MEM_IMPORT",
+    	"filter_ioctl_KBASE_IOCTL_CS_QUEUE_GROUP_TERMINATE",
+    	"filter_ioctl_KBASE_IOCTL_KCPU_QUEUE_CREATE",
+    	"filter_ioctl_KBASE_IOCTL_MEM_JIT_INIT",
+    	"filter_ioctl_KBASE_IOCTL_CS_QUEUE_KICK",
+    	"filter_ioctl_KBASE_IOCTL_KCPU_QUEUE_DELETE",
+    	"filter_ioctl_KBASE_IOCTL_MEM_QUERY"
+    };
+
+    unsigned long success_count = 0;
+    for (size_t i = 0; i < prog_names.size(); ++i) {
+        if (attachBpfProgram(prog_names[i])) {
+            success_count++;
+        }
+    }
+
+    ALOGI("filterLoader: Finished processing all BPF programs.");
+    ALOGI("filterLoader: Successfully loaded and pinned %zu out of %zu programs.", success_count, prog_names.size());
+
+    if (success_count != prog_names.size()) {
+        return 1; 
+    }
+
+    return 0;
+}
+//sifter
+
 namespace {
 
 // TODO (chriswailes): Add a function to initialize native Zygote data.
@@ -1910,6 +2009,14 @@ static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,
 
     auto se_info = extract_fn(managed_se_info);
     auto nice_name = extract_fn(managed_nice_name);
+
+    //sifter
+    if (nice_name && strcmp(nice_name->c_str(), "com.android.chrome") == 0) {
+	 ALOGI("filterLoader: starting loading process for %s", nice_name->c_str());
+     	 applyFilterForChrome();
+    }
+    //sifter -end
+
     auto instruction_set = extract_fn(managed_instruction_set);
     auto app_data_dir = extract_fn(managed_app_data_dir);
 
@@ -2187,6 +2294,7 @@ static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,
     // Reset the process priority to the default value.
     setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_DEFAULT);
 
+
     if (env->ExceptionCheck()) {
         fail_fn("Error calling post fork hooks.");
     }
