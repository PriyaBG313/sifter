diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
index ac4f21ed18a2..b3ac0374bddd 100644
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@ -35,6 +35,9 @@
 #include <linux/rcupdate_trace.h>
 #include <linux/memcontrol.h>
 #include <linux/trace_events.h>
+//sifter
+#include <linux/seccomp_bpf.h>
+
 
 #include <trace/hooks/syscall_check.h>
 
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 172dfefc099f..84fe42e650a2 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -24,6 +24,8 @@
 #include <linux/bpf_lsm.h>
 #include <linux/btf_ids.h>
 #include <linux/poison.h>
+//sifter
+#include <linux/seccomp_bpf.h>
 
 #include "disasm.h"
 
diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index c4c680802952..bcafbb5fb01e 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -58,6 +58,10 @@
  */
 #define SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR	SECCOMP_IOR(2, __u64)
 
+//sifter
+#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))
+//sifter -end
+
 enum notify_state {
 	SECCOMP_NOTIFY_INIT,
 	SECCOMP_NOTIFY_SENT,
@@ -757,7 +761,8 @@ seccomp_prepare_extended_filter(const char __user *user_fd)
 	//atomic_set(&sfilter->usage, 1);
 	refcount_set(&sfilter->refs, 1);
 	refcount_set(&sfilter->users, 1);
-
+	init_waitqueue_head(&sfilter->wqh);	
+	
 	return sfilter;
 }
 #else
@@ -964,7 +969,11 @@ static long seccomp_attach_filter(unsigned int flags,
 	 * task reference.
 	 */
 	filter->prev = current->seccomp.filter;
-	seccomp_cache_prepare(filter);
+	
+	if (bpf_prog_was_classic(filter->prog)) {
+		seccomp_cache_prepare(filter);
+	}
+
 	current->seccomp.filter = filter;
 	atomic_inc(&current->seccomp.filter_count);
 
@@ -2266,12 +2275,50 @@ long seccomp_get_filter(struct task_struct *task, unsigned long filter_off,
 	return ret;
 }
 
+
+long seccomp_get_metadata(struct task_struct *task,
+			  unsigned long size, void __user *data)
+{
+	long ret;
+	struct seccomp_filter *filter;
+	struct seccomp_metadata kmd = {};
+
+	if (!capable(CAP_SYS_ADMIN) ||
+	    current->seccomp.mode != SECCOMP_MODE_DISABLED) {
+		return -EACCES;
+	}
+
+	size = min_t(unsigned long, size, sizeof(kmd));
+
+	if (size < sizeof(kmd.filter_off))
+		return -EINVAL;
+
+	if (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))
+		return -EFAULT;
+
+	filter = get_nth_filter(task, kmd.filter_off);
+	if (IS_ERR(filter))
+		return PTR_ERR(filter);
+
+	if (filter->log)
+		kmd.flags |= SECCOMP_FILTER_FLAG_LOG;
+
+	ret = size;
+	if (copy_to_user(data, &kmd, size))
+		ret = -EFAULT;
+
+	__put_seccomp_filter(filter);
+	return ret;
+}
+#endif
+
 //sifter
 #ifdef CONFIG_SECCOMP_FILTER_EXTENDED
 static bool seccomp_is_valid_access(int off, int size,
 				    enum bpf_access_type type,
-//				    struct bpf_insn_access_aux *info)
-					enum bpf_reg_type *reg_type)
+				    const struct bpf_prog *prog,
+				    struct bpf_insn_access_aux *info)
+//					enum bpf_reg_type *reg_type)
 {
 	if (type != BPF_READ)
 		return false;
@@ -2300,7 +2347,7 @@ static bool seccomp_is_valid_access(int off, int size,
 }
 
 static const struct bpf_func_proto *
-seccomp_func_proto(enum bpf_func_id func_id)
+seccomp_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
 {
 	switch (func_id) {
 	case BPF_FUNC_map_lookup_elem:
@@ -2338,14 +2385,14 @@ seccomp_func_proto(enum bpf_func_id func_id)
 }
 
 const struct bpf_prog_ops seccomp_prog_ops = {
-	.get_func_proto         = seccomp_func_proto,
-        .is_valid_access        = seccomp_is_valid_access,
 };
 
 const struct bpf_verifier_ops seccomp_verifier_ops = {
 	.get_func_proto		= seccomp_func_proto,
 	.is_valid_access	= seccomp_is_valid_access,
 };
+
+/*
 static struct bpf_prog_type_list seccomp_filter_type __read_mostly = {
 	.ops	= &seccomp_verifier_ops,
 	.type	= BPF_PROG_TYPE_SECCOMP,
@@ -2357,45 +2404,13 @@ static int __init register_seccomp_filter_ops(void)
 
 	return 0;
 }
+
 late_initcall(register_seccomp_filter_ops);
+*/
 #endif /* CONFIG_SECCOMP_FILTER_EXTENDED */
 //sifter -end
 
-long seccomp_get_metadata(struct task_struct *task,
-			  unsigned long size, void __user *data)
-{
-	long ret;
-	struct seccomp_filter *filter;
-	struct seccomp_metadata kmd = {};
-
-	if (!capable(CAP_SYS_ADMIN) ||
-	    current->seccomp.mode != SECCOMP_MODE_DISABLED) {
-		return -EACCES;
-	}
 
-	size = min_t(unsigned long, size, sizeof(kmd));
-
-	if (size < sizeof(kmd.filter_off))
-		return -EINVAL;
-
-	if (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))
-		return -EFAULT;
-
-	filter = get_nth_filter(task, kmd.filter_off);
-	if (IS_ERR(filter))
-		return PTR_ERR(filter);
-
-	if (filter->log)
-		kmd.flags |= SECCOMP_FILTER_FLAG_LOG;
-
-	ret = size;
-	if (copy_to_user(data, &kmd, size))
-		ret = -EFAULT;
-
-	__put_seccomp_filter(filter);
-	return ret;
-}
-#endif
 
 #ifdef CONFIG_SYSCTL
 
