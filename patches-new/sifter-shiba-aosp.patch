diff --git a/android/abi_gki_aarch64.stg b/android/abi_gki_aarch64.stg
index 99755075c7ec..0b8afe835e10 100644
--- a/android/abi_gki_aarch64.stg
+++ b/android/abi_gki_aarch64.stg
@@ -279656,9 +279656,17 @@ enumeration {
       name: "BPF_FUNC_user_ringbuf_drain"
       value: 209
     }
+    enumerator {
+      name: "BPF_FUNC_probe_read_sleepable"
+      value: 212
+    }
+    enumerator {
+      name: "BPF_FUNC_check_fd"
+      value: 213
+    }
     enumerator {
       name: "__BPF_FUNC_MAX_ID"
-      value: 210
+      value: 214
     }
   }
 }
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 69d231e9a199..3a48f0054b85 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -2599,6 +2599,12 @@ extern const struct bpf_func_proto bpf_set_retval_proto;
 extern const struct bpf_func_proto bpf_get_retval_proto;
 extern const struct bpf_func_proto bpf_user_ringbuf_drain_proto;
 
+//sifter
+extern const struct bpf_func_proto bpf_probe_read_sleepable_proto;
+extern const struct bpf_func_proto bpf_check_fd_proto;
+//sifter -end
+
+
 const struct bpf_func_proto *tracing_prog_func_proto(
   enum bpf_func_id func_id, const struct bpf_prog *prog);
 
diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h
index 5db390d63a51..d318b7a14264 100644
--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -432,8 +432,9 @@ struct bpf_insn_aux_data {
 	bool prune_point;
 };
 
-#define MAX_USED_MAPS 64 /* max number of maps accessed by one eBPF program */
-#define MAX_USED_BTFS 64 /* max number of BTFs accessed by one BPF program */
+/*sifter increased MAX_USED_MAPS and MAX_USED_BTFS from 64 to 1024*/
+#define MAX_USED_MAPS 1024 /* max number of maps accessed by one eBPF program */
+#define MAX_USED_BTFS 1024 /* max number of BTFs accessed by one BPF program */
 
 #define BPF_VERIFIER_TMP_LOG_SIZE	1024
 
diff --git a/include/net/netlink.h b/include/net/netlink.h
index a686c9041ddc..da73a7c29ac7 100644
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@ -320,7 +320,7 @@ enum nla_policy_validation {
 struct nla_policy {
 	u8		type;
 	u8		validation_type;
-	u16		len;
+	u64		len;
 	union {
 		/**
 		 * @strict_start_type: first attribute to validate strictly
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index 3dfe140df9e6..5d354f9a99f1 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -5693,8 +5693,13 @@ union bpf_attr {
 	FN(tcp_raw_check_syncookie_ipv6),	\
 	FN(ktime_get_tai_ns),		\
 	FN(user_ringbuf_drain),		\
+ 	FN(cgrp_storage_get),		\
+ 	FN(cgrp_storage_delete),	\
+ 	FN(probe_read_sleepable),	\
+ 	FN(check_fd),			\
 	/* */
 
+/*sifter added probe_read_sleepable and check_fd*/
 /* integer value in 'imm' field of BPF_CALL instruction selects which helper
  * function eBPF program intends to call
  */
diff --git a/include/uapi/linux/bpf_common.h b/include/uapi/linux/bpf_common.h
index ee97668bdadb..5b411a6fd769 100644
--- a/include/uapi/linux/bpf_common.h
+++ b/include/uapi/linux/bpf_common.h
@@ -1,4 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*sifter changed MAXINSNS*/
 #ifndef _UAPI__LINUX_BPF_COMMON_H__
 #define _UAPI__LINUX_BPF_COMMON_H__
 
@@ -51,7 +52,7 @@
 #define		BPF_X		0x08
 
 #ifndef BPF_MAXINSNS
-#define BPF_MAXINSNS 4096
+#define BPF_MAXINSNS 65536
 #endif
 
 #endif /* _UAPI__LINUX_BPF_COMMON_H__ */
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index a4f3ea6c5f37..172dfefc099f 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -12944,12 +12944,12 @@ static int check_map_prog_compatibility(struct bpf_verifier_env *env,
 			verbose(env, "socket filter progs cannot use bpf_spin_lock yet\n");
 			return -EINVAL;
 		}
-
+		/*sifter
 		if (is_tracing_prog_type(prog_type)) {
 			verbose(env, "tracing progs cannot use bpf_spin_lock yet\n");
 			return -EINVAL;
 		}
-
+		*/
 		if (prog->aux->sleepable) {
 			verbose(env, "sleepable progs cannot use bpf_spin_lock yet\n");
 			return -EINVAL;
diff --git a/kernel/trace/bpf_trace.c b/kernel/trace/bpf_trace.c
index cc98e523af42..b0e92e7d37df 100644
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@ -33,6 +33,12 @@
 #include "trace_probe.h"
 #include "trace.h"
 
+//sifter
+#include <linux/file.h>
+#include <linux/fdtable.h>
+#include <linux/namei.h>
+#include <linux/sched.h>
+//sifter -end
 #define CREATE_TRACE_POINTS
 #include "bpf_trace.h"
 
@@ -142,6 +148,64 @@ unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)
 	return ret;
 }
 
+//sifter
+BPF_CALL_2(bpf_check_fd, char *, path, u32, fd)
+{
+	int ret;
+	struct file *file;
+	struct path c_path;
+	unsigned long flags;
+
+	ret = kern_path(path, LOOKUP_FOLLOW, &c_path);
+	if (ret)
+		return 0;
+
+	rcu_read_lock();
+	spin_lock_irqsave(&current->files->file_lock, flags);
+	file = files_lookup_fd_locked(current->files, fd);
+	//file = fdget(fd);
+	
+	if (file && file->f_path.dentry) {
+		ret = (d_backing_inode(c_path.dentry) == d_backing_inode(file->f_path.dentry))? 1 : 0;
+	} else {
+		ret = 0;
+	}
+
+	spin_unlock_irqrestore(&current->files->file_lock, flags);
+	rcu_read_unlock();
+	path_put(&c_path);
+	return ret;
+}
+
+const struct bpf_func_proto bpf_check_fd_proto = {
+	.func		= bpf_check_fd,
+	.gpl_only	= true,
+	.ret_type	= RET_INTEGER,
+	.arg1_type	= ARG_PTR_TO_STACK,
+	.arg2_type	= ARG_ANYTHING,
+};
+
+BPF_CALL_3(bpf_probe_read_sleepable, void *, dst, u32, size, const void *, unsafe_ptr)
+{
+	int ret;
+
+	ret = copy_from_user(dst, unsafe_ptr, size);
+	if (unlikely(ret < 0))
+		memset(dst, 0, size);
+
+	return ret;
+}
+
+const struct bpf_func_proto bpf_probe_read_sleepable_proto = {
+	.func		= bpf_probe_read_sleepable,
+	.gpl_only	= true,
+	.ret_type	= RET_INTEGER,
+	.arg1_type	= ARG_PTR_TO_UNINIT_MEM,
+	.arg2_type	= ARG_CONST_SIZE,
+	.arg3_type	= ARG_ANYTHING,
+};
+//sifter -end
+
 #ifdef CONFIG_BPF_KPROBE_OVERRIDE
 BPF_CALL_2(bpf_override_return, struct pt_regs *, regs, unsigned long, rc)
 {
@@ -1463,6 +1527,12 @@ bpf_tracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
 	case BPF_FUNC_probe_read_kernel_str:
 		return security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?
 		       NULL : &bpf_probe_read_kernel_str_proto;
+	//sifter
+	case BPF_FUNC_probe_read_sleepable:
+		return &bpf_probe_read_sleepable_proto;
+	case BPF_FUNC_check_fd:
+		return &bpf_check_fd_proto;
+	//sifter -end
 #ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE
 	case BPF_FUNC_probe_read:
 		return security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?
